<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FTC Triangulation Tool (Mobile)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c2c2c;
            color: white;
            overflow: hidden; /* Prevent body scroll */
        }

        /* Layout Container */
        #main-layout {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Left Side: Field Display */
        #field-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-color: #1a1a1a;
            overflow: hidden;
        }

        #canvas-wrapper {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #000;
            /* Default for desktop: maximize based on smallest dimension */
            width: 90vmin; 
            height: 90vmin;
        }

        #field-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 2;
            touch-action: none; /* Crucial: disables browser handling of gestures */
        }

        #field-bg {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: repeating-linear-gradient(
                45deg,
                #606dbc,
                #606dbc 10px,
                #465298 10px,
                #465298 20px
            );
        }

        /* Tooltip */
        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            display: none;
            z-index: 10;
            border: 1px solid #555;
        }

        /* Right Side: Data Table & Controls */
        #sidebar {
            width: 380px; 
            min-width: 300px;
            background-color: #2c2c2c;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
            z-index: 20;
        }

        .sidebar-header {
            padding: 15px;
            background-color: #383838;
            border-bottom: 1px solid #444;
        }

        h2 { margin: 0 0 10px 0; font-size: 1.1rem; }
        p.instructions { margin: 0; font-size: 0.8rem; color: #aaa; line-height: 1.4; }

        .table-container {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
        }

        /* Mobile Controls */
        #controls-area {
            padding: 10px;
            background: #252525;
            border-top: 1px solid #444;
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .rotate-btn {
            background-color: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 15px 25px;
            font-size: 1.2rem;
            cursor: pointer;
            user-select: none; /* Prevent text selection on rapid click */
            touch-action: manipulation;
            font-weight: bold;
            flex: 1;
            max-width: 150px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .rotate-btn:active {
            background-color: #4CAF50;
            border-color: #4CAF50;
        }

        /* Data Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem; 
            margin-top: 10px;
        }

        th, td {
            padding: 10px 6px;
            text-align: left;
            border-bottom: 1px solid #444;
        }

        th { color: #aaa; font-weight: 600; background: #333; }
        td { color: #eee; }
        
        .target-row { border-left: 4px solid #FF5722; background-color: #353535; }
        .target-row-2 { border-left: 4px solid #2196F3; background-color: #353535; }

        .data-val { 
            font-family: monospace; 
            font-size: 1.1em; 
            color: #64b5f6; 
            font-weight: bold; 
        }

        #status-container {
            background: #222;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            border: 1px solid #444;
            display: flex;
            flex-direction: column;
            gap: 6px; 
        }

        #current-pos-display, #heading-display {
            font-family: monospace;
            font-size: 1.0em;
            color: #4CAF50;
            text-align: left;
            margin: 0;
        }

        /* --- MOBILE RESPONSIVE CSS --- */
        @media (max-width: 800px) {
            body { overflow: auto; } /* Allow scroll if needed on very small screens */
            #main-layout {
                flex-direction: column; /* Stack vertically */
            }

            #field-container {
                flex: none; /* Don't stretch indefinitely */
                width: 100%;
                /* Maintain square aspect ratio manually via JS or simplified height */
                height: auto;
                padding: 10px 0;
            }

            #canvas-wrapper {
                /* On mobile, occupy most of the width */
                width: 95vw;
                height: 95vw; 
            }

            #sidebar {
                width: 100%;
                border-left: none;
                border-top: 1px solid #444;
                flex: 1; /* Take remaining height */
                box-shadow: none;
            }
            
            .sidebar-header { display: none; } /* Save space on mobile */
            
            #controls-area {
                order: -1; /* Move buttons to top of sidebar */
                border-bottom: 1px solid #444;
                border-top: none;
            }
        }

    </style>
</head>
<body>

<div id="main-layout">
    <div id="field-container">
        <div id="canvas-wrapper">
            <img id="field-bg" src="ftc-field.png" alt="FTC Field Image" onerror="this.style.display='none';">
            <canvas id="field-canvas"></canvas>
        </div>
        <div id="tooltip">0, 0</div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">
            <h2>Position Check</h2>
            <p class="instructions">
                <b>Tap/Drag</b>: Move Robot<br>
                <b>Buttons/Keys</b>: Rotate<br>
                <span style="color: #FF0000;">Red</span>: (-66, 58) | <span style="color: #2196F3;">Blue</span>: (-66, -58)<br>
                Offset: Turret 4" West
            </p>
        </div>

        <div id="controls-area">
            <div class="rotate-btn" id="btn-left" oncontextmenu="return false;">&#8634; Left</div>
            <div class="rotate-btn" id="btn-right" oncontextmenu="return false;">Right &#8635;</div>
        </div>

        <div class="table-container">
            <div id="status-container">
                <div id="current-pos-display">Select a point...</div>
                <div id="heading-display">Robot Heading: 0.0°</div>
            </div>
            
            <table>
                <thead>
                    <tr>
                        <th>Target</th>
                        <th>Dist (in)</th>
                        <th>Field (°)</th>
                        <th>Turret (°)</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    </tbody>
            </table>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('field-canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const tableBody = document.getElementById('table-body');
    const posDisplay = document.getElementById('current-pos-display');
    const headingDisplay = document.getElementById('heading-display');
    const wrapper = document.getElementById('canvas-wrapper');

    // Field Config
    const FIELD_SIZE_INCHES = 144;
    const TURRET_OFFSET_DIST = 4; 
    
    // Fixed Targets
    const TARGETS = [
        { x: -66, y: 58, color: '#FF5722', label: "Red Goal" },
        { x: -66, y: -58, color: '#2196F3', label: "Blue Goal" } 
    ];

    // State
    let userPoint = null; 
    let robotHeading = 0; 
    let isDragging = false;
    let rotationInterval = null; // For holding down buttons

    // --- Coordinate Conversion ---

    function resizeCanvas() {
        // Use client dims to ensure 1:1 mapping with CSS size
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        render();
    }
    
    function toFieldCoords(canvasX, canvasY) {
        const scale = FIELD_SIZE_INCHES / canvas.width;
        let x = (canvasX * scale) - (FIELD_SIZE_INCHES / 2);
        let y = (FIELD_SIZE_INCHES / 2) - (canvasY * scale);
        return { x, y };
    }

    function toCanvasCoords(fieldX, fieldY) {
        const scale = canvas.width / FIELD_SIZE_INCHES;
        let x = (fieldX + (FIELD_SIZE_INCHES / 2)) * scale;
        let y = ((FIELD_SIZE_INCHES / 2) - fieldY) * scale;
        return { x, y };
    }

    function getTurretFieldPos() {
        if (!userPoint) return null;
        const dx = -TURRET_OFFSET_DIST * Math.cos(robotHeading);
        const dy = -TURRET_OFFSET_DIST * Math.sin(robotHeading);
        return { x: userPoint.x + dx, y: userPoint.y + dy };
    }

    // --- Interaction ---

    function getEventPos(evt) {
        const rect = canvas.getBoundingClientRect();
        // Handle Touch vs Mouse
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        return { x: clientX - rect.left, y: clientY - rect.top };
    }

    function handleInputStart(e) {
        // Prevent default only if on canvas to allow scrolling elsewhere
        if(e.target === canvas) e.preventDefault(); 
        
        const pos = getEventPos(e);
        const fieldPos = toFieldCoords(pos.x, pos.y);
        
        // Logic: Ctrl+Click deletes, otherwise places/drags
        if (e.ctrlKey) {
            userPoint = null; 
        } else {
            userPoint = { x: fieldPos.x, y: fieldPos.y };
            isDragging = true;
        }
        render();
        updateTable();
    }

    function handleInputMove(e) {
        if (!isDragging && e.type !== 'mousemove') return; // Only track hover on mouse
        if(e.target === canvas) e.preventDefault(); 

        const pos = getEventPos(e);
        const fieldPos = toFieldCoords(pos.x, pos.y);

        // Tooltip logic
        if (e.type === 'mousemove') {
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
            tooltip.textContent = `X: ${fieldPos.x.toFixed(1)}", Y: ${fieldPos.y.toFixed(1)}"`;
        }

        if (isDragging) {
            userPoint = { x: fieldPos.x, y: fieldPos.y };
            render();
            updateTable();
        } else if (userPoint && e.type === 'mousemove') {
            // Hover cursor change
            const screenP = toCanvasCoords(userPoint.x, userPoint.y);
            const dist = Math.hypot(pos.x - screenP.x, pos.y - screenP.y);
            canvas.style.cursor = (dist < 10) ? 'move' : 'crosshair';
        }
    }

    function handleInputEnd(e) {
        if(e.target === canvas) e.preventDefault();
        isDragging = false;
    }

    // Event Listeners (Mouse)
    canvas.addEventListener('mousedown', handleInputStart);
    canvas.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);
    canvas.addEventListener('mouseout', () => { tooltip.style.display = 'none'; });

    // Event Listeners (Touch)
    canvas.addEventListener('touchstart', handleInputStart, {passive: false});
    canvas.addEventListener('touchmove', handleInputMove, {passive: false});
    window.addEventListener('touchend', handleInputEnd);

    // --- Rotation Controls ---

    function rotateRobot(direction) {
        if (!userPoint) return;
        const ROT_SPEED = (2 * Math.PI) / 180; // 2 deg
        if (direction === 'left') robotHeading += ROT_SPEED;
        else robotHeading -= ROT_SPEED;
        render();
        updateTable();
    }

    // Keyboard
    window.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') rotateRobot('left');
        if (e.key === 'ArrowRight') rotateRobot('right');
    });

    // On-Screen Buttons (Hold to rotate)
    const btnLeft = document.getElementById('btn-left');
    const btnRight = document.getElementById('btn-right');

    function startRotation(direction) {
        if(rotationInterval) clearInterval(rotationInterval);
        rotateRobot(direction); // Immediate trigger
        rotationInterval = setInterval(() => rotateRobot(direction), 50); // Loop
    }

    function stopRotation() {
        if(rotationInterval) clearInterval(rotationInterval);
    }

    // Wire up buttons (Mouse + Touch)
    btnLeft.addEventListener('mousedown', () => startRotation('left'));
    btnLeft.addEventListener('touchstart', (e) => { e.preventDefault(); startRotation('left'); });
    
    btnRight.addEventListener('mousedown', () => startRotation('right'));
    btnRight.addEventListener('touchstart', (e) => { e.preventDefault(); startRotation('right'); });

    ['mouseup', 'mouseleave', 'touchend'].forEach(evt => {
        btnLeft.addEventListener(evt, stopRotation);
        btnRight.addEventListener(evt, stopRotation);
    });

    // Window Resize
    window.addEventListener('resize', resizeCanvas);

    // --- Rendering ---

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Fixed Targets
        TARGETS.forEach(t => {
            const p = toCanvasCoords(t.x, t.y);
            ctx.beginPath();
            ctx.strokeStyle = t.color;
            ctx.lineWidth = 3;
            ctx.moveTo(p.x - 8, p.y);
            ctx.lineTo(p.x + 8, p.y);
            ctx.moveTo(p.x, p.y - 8);
            ctx.lineTo(p.x, p.y + 8);
            ctx.stroke();
            ctx.fillStyle = t.color;
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(t.label, p.x + 10, p.y - 10);
        });

        // 2. Draw User Point details
        if (userPoint) {
            const up = toCanvasCoords(userPoint.x, userPoint.y);
            const scale = canvas.width / FIELD_SIZE_INCHES;
            
            // Get Turret Position
            const turretField = getTurretFieldPos();
            const tp_screen = toCanvasCoords(turretField.x, turretField.y);

            // --- Draw Rotated Robot Body ---
            const squareSizePx = 18 * scale; 
            const halfSquare = squareSizePx / 2;
            const circleRadiusPx = 2.5 * scale;
            const turretOffsetPx = TURRET_OFFSET_DIST * scale;

            ctx.save();
            ctx.translate(up.x, up.y);
            ctx.rotate(-robotHeading); 
            
            // Square
            ctx.fillStyle = 'rgba(100, 100, 100, 0.4)'; 
            ctx.fillRect(-halfSquare, -halfSquare, squareSizePx, squareSizePx);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; 
            ctx.lineWidth = 2;
            ctx.strokeRect(-halfSquare, -halfSquare, squareSizePx, squareSizePx);

            // Turret Circle
            ctx.beginPath();
            ctx.arc(-turretOffsetPx, 0, circleRadiusPx, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; 
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; 
            ctx.lineWidth = 2;
            ctx.stroke();

            // Green Heading Line
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(halfSquare, 0); 
            ctx.strokeStyle = '#4CAF50'; 
            ctx.lineWidth = 5;
            ctx.stroke();
            
            ctx.restore();

            // Common Geometry
            const arcRadius = 16 * scale; 
            const arrowLen = 12; 
            const arrowWidth = 7; 

            // RED ARC (CCW)
            const t1 = TARGETS[0];
            const p1 = toCanvasCoords(t1.x, t1.y);
            const angle1 = Math.atan2(p1.y - tp_screen.y, p1.x - tp_screen.x);
            
            ctx.beginPath();
            ctx.strokeStyle = t1.color; 
            ctx.lineWidth = 4;
            ctx.arc(tp_screen.x, tp_screen.y, arcRadius, 0, angle1, true); 
            ctx.stroke();

            let endX = tp_screen.x + arcRadius * Math.cos(angle1);
            let endY = tp_screen.y + arcRadius * Math.sin(angle1);
            ctx.save(); 
            ctx.translate(endX, endY);
            ctx.rotate(angle1 - Math.PI / 2); 
            drawArrowHead(ctx, t1.color, arrowLen, arrowWidth);
            ctx.restore();

            let deg1 = -angle1 * (180 / Math.PI);
            if (deg1 < 0) deg1 += 360;
            drawLabel(ctx, deg1.toFixed(2) + '°', t1.color, tp_screen, arcRadius, angle1);

            // BLUE ARC (CW)
            const t2 = TARGETS[1];
            const p2 = toCanvasCoords(t2.x, t2.y);
            const angle2 = Math.atan2(p2.y - tp_screen.y, p2.x - tp_screen.x);

            ctx.beginPath();
            ctx.strokeStyle = t2.color; 
            ctx.lineWidth = 4;
            ctx.arc(tp_screen.x, tp_screen.y, arcRadius, 0, angle2, false); 
            ctx.stroke();

            endX = tp_screen.x + arcRadius * Math.cos(angle2);
            endY = tp_screen.y + arcRadius * Math.sin(angle2);
            ctx.save(); 
            ctx.translate(endX, endY);
            ctx.rotate(angle2 + Math.PI / 2); 
            drawArrowHead(ctx, t2.color, arrowLen, arrowWidth);
            ctx.restore();

            let deg2 = -angle2 * (180 / Math.PI);
            drawLabel(ctx, deg2.toFixed(2) + '°', t2.color, tp_screen, arcRadius, angle2);
            
            // Crosshairs (Yellow) at TURRET
            const pixelRadius = 24 * scale; 
            ctx.beginPath();
            ctx.strokeStyle = '#FFEB3B'; 
            ctx.lineWidth = 2;
            ctx.moveTo(tp_screen.x - pixelRadius, tp_screen.y);
            ctx.lineTo(tp_screen.x + pixelRadius, tp_screen.y);
            ctx.moveTo(tp_screen.x, tp_screen.y - pixelRadius);
            ctx.lineTo(tp_screen.x, tp_screen.y + pixelRadius);
            ctx.stroke();
            
            // Lines & Labels
            TARGETS.forEach(t => {
                const tp = toCanvasCoords(t.x, t.y);
                ctx.beginPath();
                ctx.setLineDash([5, 5]); 
                ctx.strokeStyle = t.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.moveTo(tp_screen.x, tp_screen.y);
                ctx.lineTo(tp.x, tp.y);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
                ctx.setLineDash([]); 

                const dist = Math.hypot(t.x - turretField.x, t.y - turretField.y);
                const midX = (tp_screen.x + tp.x) / 2;
                const midY = (tp_screen.y + tp.y) / 2;
                
                ctx.save();
                ctx.font = 'bold 20px monospace';
                const distText = dist.toFixed(2) + '"';
                const tm = ctx.measureText(distText);
                const pad = 4;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(midX - tm.width/2 - pad, midY - 14, tm.width + pad*2, 28);
                ctx.fillStyle = t.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(distText, midX, midY);
                ctx.restore();
            });

            // Dots
            ctx.beginPath(); // Robot Center
            ctx.arc(up.x, up.y, 4, 0, Math.PI * 2); 
            ctx.fillStyle = '#FFEB3B'; 
            ctx.strokeStyle = '#fff'; 
            ctx.lineWidth = 1;
            ctx.fill(); ctx.stroke();

            ctx.beginPath(); // Turret Center
            ctx.arc(tp_screen.x, tp_screen.y, 5, 0, Math.PI * 2); 
            ctx.fillStyle = '#FFEB3B'; 
            ctx.lineWidth = 2;
            ctx.fill(); ctx.stroke();
        }
    }

    function drawArrowHead(ctx, color, len, width) {
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(-len, -width); 
        ctx.lineTo(-len + 3, 0); 
        ctx.lineTo(-len, width); 
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }

    function drawLabel(ctx, text, color, center, radius, angle) {
        ctx.save();
        ctx.font = 'bold 20px monospace';
        const midAngle = angle / 2; 
        const labelDist = radius + 35; 
        const labelX = center.x + labelDist * Math.cos(midAngle);
        const labelY = center.y + labelDist * Math.sin(midAngle);
        const textMetrics = ctx.measureText(text);
        const boxWidth = textMetrics.width + 10;
        const boxHeight = 28;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(labelX - boxWidth / 2, labelY - boxHeight / 2, boxWidth, boxHeight);
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, labelX, labelY + 2); 
        ctx.restore();
    }

    function updateTable() {
        tableBody.innerHTML = '';
        if (!userPoint) {
            posDisplay.textContent = "Click field to place point";
            posDisplay.style.color = "#777";
            headingDisplay.textContent = "";
            return;
        }

        posDisplay.textContent = `Robot Center: (${userPoint.x.toFixed(1)}, ${userPoint.y.toFixed(1)})`;
        posDisplay.style.color = "#4CAF50";
        
        let normRad = robotHeading % (2 * Math.PI);
        if (normRad < 0) normRad += (2 * Math.PI);
        let deg = normRad * (180 / Math.PI);
        if (deg > 180) deg -= 360;
        headingDisplay.textContent = `Robot Heading: ${deg.toFixed(1)}°`;
        
        const turretField = getTurretFieldPos();

        TARGETS.forEach((t, index) => {
            const dist = Math.hypot(t.x - turretField.x, t.y - turretField.y);
            const dx = t.x - turretField.x;
            const dy = t.y - turretField.y;
            
            let fieldAngleRad = Math.atan2(dy, dx);
            let fieldAngleDeg = fieldAngleRad * (180 / Math.PI);

            let relRad = fieldAngleRad - robotHeading;
            while (relRad <= -Math.PI) relRad += 2*Math.PI;
            while (relRad > Math.PI) relRad -= 2*Math.PI;
            let relDeg = relRad * (180 / Math.PI);

            if (index === 0) { 
                if (fieldAngleDeg < 0) fieldAngleDeg += 360;
            } 

            const tr = document.createElement('tr');
            tr.className = index === 0 ? 'target-row' : 'target-row-2';
            
            const tdName = document.createElement('td');
            tdName.innerHTML = `<b>${t.label}</b>`;
            tr.appendChild(tdName);
            
            const tdDist = document.createElement('td');
            tdDist.className = 'data-val';
            tdDist.textContent = dist.toFixed(2) + '"';
            tr.appendChild(tdDist);

            const tdFieldAngle = document.createElement('td');
            tdFieldAngle.className = 'data-val';
            tdFieldAngle.textContent = fieldAngleDeg.toFixed(2) + '°';
            tr.appendChild(tdFieldAngle);
            
            const tdRelAngle = document.createElement('td');
            tdRelAngle.className = 'data-val';
            tdRelAngle.style.color = '#fff';
            const sign = relDeg >= 0 ? '+' : '';
            tdRelAngle.textContent = sign + relDeg.toFixed(2) + '°';
            tr.appendChild(tdRelAngle);

            tableBody.appendChild(tr);
        });
    }

    // Init
    resizeCanvas();
    setTimeout(resizeCanvas, 100);

</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FTC Triangulation Tool</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #2c2c2c;
            color: white;
            overflow: hidden;
        }

        /* Left Side: Field Display */
        #field-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            background-color: #1a1a1a;
            overflow: hidden;
        }

        #canvas-wrapper {
            position: relative;
            width: 90vmin; 
            height: 90vmin;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #000;
        }

        #field-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            z-index: 2;
        }

        #field-bg {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            background: repeating-linear-gradient(
                45deg,
                #606dbc,
                #606dbc 10px,
                #465298 10px,
                #465298 20px
            );
        }

        /* Tooltip */
        #tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 14px;
            display: none;
            z-index: 10;
            border: 1px solid #555;
        }

        /* Right Side: Data Table */
        #sidebar {
            width: 380px; 
            background-color: #2c2c2c;
            border-left: 1px solid #444;
            display: flex;
            flex-direction: column;
            box-shadow: -5px 0 15px rgba(0,0,0,0.3);
        }

        .sidebar-header {
            padding: 20px;
            background-color: #383838;
            border-bottom: 1px solid #444;
        }

        h2 { margin: 0 0 10px 0; font-size: 1.2rem; }
        p.instructions { margin: 0; font-size: 0.85rem; color: #aaa; line-height: 1.4; }

        .table-container {
            flex: 1;
            padding: 10px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #444;
        }

        th { color: #aaa; font-weight: 600; background: #333; }
        td { color: #eee; }
        
        .target-row { border-left: 4px solid #FF5722; background-color: #353535; }
        .target-row-2 { border-left: 4px solid #2196F3; background-color: #353535; }

        .data-val { 
            font-family: monospace; 
            font-size: 1.1em; 
            color: #64b5f6; 
            font-weight: bold; 
        }

        #current-pos-display {
            background: #222;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
            border: 1px solid #444;
            font-family: monospace;
            text-align: center;
            font-size: 1.1em;
            color: #4CAF50;
        }
        
        #heading-display {
            text-align: center;
            color: #FFEB3B;
            font-size: 0.9em;
            margin-top: 5px;
            font-family: monospace;
        }

    </style>
</head>
<body>

    <div id="field-container">
        <div id="canvas-wrapper">
            <img id="field-bg" src="ftc-field.png" alt="FTC Field Image" onerror="this.style.display='none';">
            <canvas id="field-canvas"></canvas>
        </div>
        <div id="tooltip">0, 0</div>
    </div>

    <div id="sidebar">
        <div class="sidebar-header">
            <h2>Position Check</h2>
            <p class="instructions">
                <b>Click</b> to place Robot Center.<br>
                <b>← / → Keys</b> to rotate robot.<br>
                <br>
                <span style="color: #FF0000;">Red</span>: Red Goal (-66, 60).<br>
                <span style="color: #2196F3;">Blue</span>: Blue Goal (-66, -60).<br>
                Measurements from Turret (Offset 4").<br>
                Yellow Crosshair = Turret Center.<br>
                Green Line = Robot East (Heading).
            </p>
        </div>
        <div class="table-container">
            <div id="current-pos-display">Select a point...</div>
            <div id="heading-display">Heading: 0.0°</div>
            
            <table>
                <thead>
                    <tr>
                        <th>Target</th>
                        <th>Dist (in)</th>
                        <th>Angle (°)</th>
                    </tr>
                </thead>
                <tbody id="table-body">
                    </tbody>
            </table>
        </div>
    </div>

<script>
    const canvas = document.getElementById('field-canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const tableBody = document.getElementById('table-body');
    const posDisplay = document.getElementById('current-pos-display');
    const headingDisplay = document.getElementById('heading-display');
    const wrapper = document.getElementById('canvas-wrapper');

    // Field Config
    const FIELD_SIZE_INCHES = 144;
    // Turret is 4 inches "West" (Left) relative to robot frame
    const TURRET_OFFSET_DIST = 4; 
    
    // Fixed Targets
    const TARGETS = [
        { x: -66, y: 60, color: '#FF5722', label: "Red Goal" },
        { x: -66, y: -60, color: '#2196F3', label: "Blue Goal" } 
    ];

    // State
    let userPoint = null; // {x, y} (Robot Center)
    let robotHeading = 0; // Radians, 0 = East, CCW is positive
    let isDragging = false;

    // --- Coordinate Conversion ---

    function resizeCanvas() {
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        render();
    }
    
    function toFieldCoords(canvasX, canvasY) {
        const scale = FIELD_SIZE_INCHES / canvas.width;
        let x = (canvasX * scale) - (FIELD_SIZE_INCHES / 2);
        let y = (FIELD_SIZE_INCHES / 2) - (canvasY * scale);
        return { x, y };
    }

    function toCanvasCoords(fieldX, fieldY) {
        const scale = canvas.width / FIELD_SIZE_INCHES;
        let x = (fieldX + (FIELD_SIZE_INCHES / 2)) * scale;
        let y = ((FIELD_SIZE_INCHES / 2) - fieldY) * scale;
        return { x, y };
    }

    // Helper: Calculate Turret Field Position based on Robot Rotation
    function getTurretFieldPos() {
        if (!userPoint) return null;
        // Turret is at x=-4 local. 
        const dx = -TURRET_OFFSET_DIST * Math.cos(robotHeading);
        const dy = -TURRET_OFFSET_DIST * Math.sin(robotHeading);
        return {
            x: userPoint.x + dx,
            y: userPoint.y + dy
        };
    }

    // --- Interaction ---

    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
    }

    // Keyboard Rotation
    window.addEventListener('keydown', (e) => {
        if (!userPoint) return;
        const ROT_SPEED = (2 * Math.PI) / 180; // 2 degrees per press
        
        if (e.key === 'ArrowLeft') {
            // CCW
            robotHeading += ROT_SPEED;
            render();
            updateTable();
        } else if (e.key === 'ArrowRight') {
            // CW
            robotHeading -= ROT_SPEED;
            render();
            updateTable();
        }
    });

    // Mouse Move (Hover + Drag)
    canvas.addEventListener('mousemove', (e) => {
        const pos = getMousePos(e);
        const fieldPos = toFieldCoords(pos.x, pos.y);

        // Tooltip
        tooltip.style.display = 'block';
        tooltip.style.left = (e.clientX + 15) + 'px';
        tooltip.style.top = (e.clientY + 15) + 'px';
        tooltip.textContent = `X: ${fieldPos.x.toFixed(1)}", Y: ${fieldPos.y.toFixed(1)}"`;

        if (isDragging) {
            userPoint = { x: fieldPos.x, y: fieldPos.y };
            render();
            updateTable();
        } else {
            // Hover logic
            if (userPoint) {
                const screenP = toCanvasCoords(userPoint.x, userPoint.y);
                const dist = Math.hypot(pos.x - screenP.x, pos.y - screenP.y);
                canvas.style.cursor = (dist < 10) ? 'move' : 'crosshair';
            }
        }
    });

    canvas.addEventListener('mouseout', () => {
        tooltip.style.display = 'none';
        isDragging = false;
    });

    // Mouse Down (Place or Grab)
    canvas.addEventListener('mousedown', (e) => {
        const pos = getMousePos(e);
        const fieldPos = toFieldCoords(pos.x, pos.y);
        
        if (e.ctrlKey) {
            userPoint = null; // Delete
        } else {
            // Simply update position to click location (or start drag)
            userPoint = { x: fieldPos.x, y: fieldPos.y };
            isDragging = true;
        }
        render();
        updateTable();
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });

    window.addEventListener('resize', resizeCanvas);

    // --- Rendering ---

    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. Draw Fixed Targets
        TARGETS.forEach(t => {
            const p = toCanvasCoords(t.x, t.y);
            ctx.beginPath();
            ctx.strokeStyle = t.color;
            ctx.lineWidth = 3;
            ctx.moveTo(p.x - 8, p.y);
            ctx.lineTo(p.x + 8, p.y);
            ctx.moveTo(p.x, p.y - 8);
            ctx.lineTo(p.x, p.y + 8);
            ctx.stroke();
            ctx.fillStyle = t.color;
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(t.label, p.x + 10, p.y - 10);
        });

        // 2. Draw User Point details
        if (userPoint) {
            const up = toCanvasCoords(userPoint.x, userPoint.y);
            const scale = canvas.width / FIELD_SIZE_INCHES;
            
            // Get Turret Position in Screen Coords for Lines/Arcs
            const turretField = getTurretFieldPos();
            const tp_screen = toCanvasCoords(turretField.x, turretField.y);

            // --- Draw Rotated Robot Body ---
            const squareSizePx = 18 * scale; 
            const halfSquare = squareSizePx / 2;
            const circleRadiusPx = 2.5 * scale;
            const turretOffsetPx = TURRET_OFFSET_DIST * scale;

            ctx.save();
            ctx.translate(up.x, up.y);
            // Canvas rotates Clockwise. If heading is + (CCW), we rotate by -heading
            ctx.rotate(-robotHeading); 
            
            // Draw Square
            ctx.fillStyle = 'rgba(100, 100, 100, 0.4)'; 
            ctx.fillRect(-halfSquare, -halfSquare, squareSizePx, squareSizePx);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; 
            ctx.lineWidth = 2;
            ctx.strokeRect(-halfSquare, -halfSquare, squareSizePx, squareSizePx);

            // Draw Turret Circle (Local Coords: x = -4)
            ctx.beginPath();
            ctx.arc(-turretOffsetPx, 0, circleRadiusPx, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)'; 
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; 
            ctx.lineWidth = 2;
            ctx.stroke();

            // --- Draw Thick Green Line to East Edge ---
            ctx.beginPath();
            ctx.moveTo(0, 0); // Center
            ctx.lineTo(halfSquare, 0); // East Edge (positive X local)
            ctx.strokeStyle = '#4CAF50'; // Green
            ctx.lineWidth = 5;
            ctx.stroke();
            // -----------------------------------------------
            
            ctx.restore();
            // --------------------------------------------------

            // Common Geometry for Arcs
            const arcRadius = 16 * scale; 
            const arrowLen = 12; 
            const arrowWidth = 7; 

            // RED ARC (Red Goal, CCW) - ORIGIN IS TURRET
            const t1 = TARGETS[0];
            const p1 = toCanvasCoords(t1.x, t1.y);
            const angle1 = Math.atan2(p1.y - tp_screen.y, p1.x - tp_screen.x);
            
            ctx.beginPath();
            ctx.strokeStyle = t1.color; 
            ctx.lineWidth = 4;
            ctx.arc(tp_screen.x, tp_screen.y, arcRadius, 0, angle1, true); 
            ctx.stroke();

            let endX = tp_screen.x + arcRadius * Math.cos(angle1);
            let endY = tp_screen.y + arcRadius * Math.sin(angle1);
            ctx.save(); 
            ctx.translate(endX, endY);
            ctx.rotate(angle1 - Math.PI / 2); 
            drawArrowHead(ctx, t1.color, arrowLen, arrowWidth);
            ctx.restore();

            let deg1 = -angle1 * (180 / Math.PI);
            if (deg1 < 0) deg1 += 360;
            drawLabel(ctx, deg1.toFixed(2) + '°', t1.color, tp_screen, arcRadius, angle1);

            // BLUE ARC (Blue Goal, CW, Negative) - ORIGIN IS TURRET
            const t2 = TARGETS[1];
            const p2 = toCanvasCoords(t2.x, t2.y);
            const angle2 = Math.atan2(p2.y - tp_screen.y, p2.x - tp_screen.x);

            ctx.beginPath();
            ctx.strokeStyle = t2.color; 
            ctx.lineWidth = 4;
            ctx.arc(tp_screen.x, tp_screen.y, arcRadius, 0, angle2, false); 
            ctx.stroke();

            endX = tp_screen.x + arcRadius * Math.cos(angle2);
            endY = tp_screen.y + arcRadius * Math.sin(angle2);
            ctx.save(); 
            ctx.translate(endX, endY);
            ctx.rotate(angle2 + Math.PI / 2); 
            drawArrowHead(ctx, t2.color, arrowLen, arrowWidth);
            ctx.restore();

            let deg2 = -angle2 * (180 / Math.PI);
            drawLabel(ctx, deg2.toFixed(2) + '°', t2.color, tp_screen, arcRadius, angle2);
            
            // --- Draw Dynamic Crosshair (Yellow) at TURRET Center ---
            const pixelRadius = 12 * scale; 
            ctx.beginPath();
            ctx.strokeStyle = '#FFEB3B'; 
            ctx.lineWidth = 2;
            // Use tp_screen instead of up
            ctx.moveTo(tp_screen.x - pixelRadius, tp_screen.y);
            ctx.lineTo(tp_screen.x + pixelRadius, tp_screen.y);
            ctx.moveTo(tp_screen.x, tp_screen.y - pixelRadius);
            ctx.lineTo(tp_screen.x, tp_screen.y + pixelRadius);
            ctx.stroke();
            
            // Draw Lines and Distance Labels (From Turret)
            TARGETS.forEach(t => {
                const tp = toCanvasCoords(t.x, t.y);
                
                // Line from Turret to Goal
                ctx.beginPath();
                ctx.setLineDash([5, 5]); 
                ctx.strokeStyle = t.color;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.6;
                ctx.moveTo(tp_screen.x, tp_screen.y);
                ctx.lineTo(tp.x, tp.y);
                ctx.stroke();
                ctx.globalAlpha = 1.0;
                ctx.setLineDash([]); 

                // Distance Label calculation
                const dist = Math.hypot(t.x - turretField.x, t.y - turretField.y);
                const midX = (tp_screen.x + tp.x) / 2;
                const midY = (tp_screen.y + tp.y) / 2;
                
                ctx.save();
                ctx.font = 'bold 20px monospace';
                const distText = dist.toFixed(2) + '"';
                const tm = ctx.measureText(distText);
                const pad = 4;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(midX - tm.width/2 - pad, midY - 14, tm.width + pad*2, 28);
                ctx.fillStyle = t.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(distText, midX, midY);
                ctx.restore();
            });

            // Draw Robot Center Point (Yellow, smaller)
            // Draw Turret Center Point (Yellow, larger for the crosshair origin)
            ctx.beginPath();
            ctx.arc(tp_screen.x, tp_screen.y, 5, 0, Math.PI * 2); 
            ctx.fillStyle = '#FFEB3B'; 
            ctx.strokeStyle = '#fff'; 
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();
        }
    }

    function drawArrowHead(ctx, color, len, width) {
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(-len, -width); 
        ctx.lineTo(-len + 3, 0); 
        ctx.lineTo(-len, width); 
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
    }

    function drawLabel(ctx, text, color, center, radius, angle) {
        ctx.save();
        ctx.font = 'bold 20px monospace';
        const midAngle = angle / 2; 
        const labelDist = radius + 35; 
        const labelX = center.x + labelDist * Math.cos(midAngle);
        const labelY = center.y + labelDist * Math.sin(midAngle);
        const textMetrics = ctx.measureText(text);
        const boxWidth = textMetrics.width + 10;
        const boxHeight = 28;
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(labelX - boxWidth / 2, labelY - boxHeight / 2, boxWidth, boxHeight);
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, labelX, labelY + 2); 
        ctx.restore();
    }

    // --- Data Calculation & Table Update ---

    function updateTable() {
        tableBody.innerHTML = '';
        
        if (!userPoint) {
            posDisplay.textContent = "Click field to place point";
            posDisplay.style.color = "#777";
            headingDisplay.textContent = "";
            return;
        }

        posDisplay.textContent = `Center: (${userPoint.x.toFixed(1)}, ${userPoint.y.toFixed(1)})`;
        posDisplay.style.color = "#4CAF50";
        
        // --- UPDATED HEADING LOGIC ---
        // Range: -180 to +180
        // East = 0, North = +90, South = -90, West = +/-180
        
        // Normalize angle to 0 - 2PI first
        let normRad = robotHeading % (2 * Math.PI);
        if (normRad < 0) normRad += (2 * Math.PI);

        // Convert to degrees (0 - 360)
        let deg = normRad * (180 / Math.PI);
        
        // Convert to -180 to +180 range
        if (deg > 180) deg -= 360;
        
        headingDisplay.textContent = `Heading: ${deg.toFixed(1)}°`;
        // -----------------------------
        
        // Calculate based on Turret Center
        const turretField = getTurretFieldPos();

        TARGETS.forEach((t, index) => {
            const dist = Math.hypot(t.x - turretField.x, t.y - turretField.y);
            const dx = t.x - turretField.x;
            const dy = t.y - turretField.y;
            let angleDeg = Math.atan2(dy, dx) * (180 / Math.PI);

            if (index === 0) { // Red Goal (CCW positive)
                if (angleDeg < 0) angleDeg += 360;
            } 
            // Blue Goal naturally returns negative for CW

            const tr = document.createElement('tr');
            tr.className = index === 0 ? 'target-row' : 'target-row-2';
            
            const tdName = document.createElement('td');
            tdName.innerHTML = `<b>${t.label}</b>`;
            tr.appendChild(tdName);
            
            const tdDist = document.createElement('td');
            tdDist.className = 'data-val';
            tdDist.textContent = dist.toFixed(2) + '"';
            tr.appendChild(tdDist);

            const tdAngle = document.createElement('td');
            tdAngle.className = 'data-val';
            tdAngle.textContent = angleDeg.toFixed(2) + '°';
            tr.appendChild(tdAngle);

            tableBody.appendChild(tr);
        });
    }

    // Init
    resizeCanvas();
    setTimeout(resizeCanvas, 100);

</script>
</body>
</html>